@inject IStorageAPI Storage

<table class="table table-bordered table-hover table-sm">
    <thead>
        <tr>
            <th class="text-center">#</th>
            <th>BaseEvent</th>
            <th>ValueType</th>
            <th>Value</th>
            <th>Condition</th>
            <th>Actor</th>
        </tr>
    </thead>
    <tbody>
        @foreach (var item in detailedEvents) {
            <tr>
                <td class="text-center">@item.ID</td>
                <td class="event_list__overflow">[@item.BaseEvent.EventValue.ID] @item.BaseEvent.EventValue.Value</td>
                <td>[@item.ValueTypeEvent.EventValue.ID] @item.ValueTypeEvent.EventValue.Value</td>
                <td>@item.Value</td>
                <td class="event_list__overflow">@item.Conditions</td>
                <td>[@item.ActorEvent.EventValue.ID] @item.ActorEvent.EventValue.Value</td>
            </tr>
        }
    </tbody>
</table>

@code {
    [Parameter]
    public IEnumerable<IEvent> Items { get; set; }

    private IEnumerable<DetailedEvent> detailedEvents = Array.Empty<DetailedEvent>();

    private struct DetailedEvent {
        public int ID { get; set; }
        public IEvent BaseEvent { get; set; }
        public IEvent ValueTypeEvent { get; set; }
        public string Value { get; set; }
        public string Conditions { get; set; }
        public IEvent ActorEvent { get; set; }
        public DateTime Date { get; set; }
    }

    protected override async Task OnParametersSetAsync() {
        await Task.Yield();
        await Refresh();
    }

    private async Task<DetailedEvent> GetDetailedEvent(IEvent e) {
        return new DetailedEvent {
            ID = e.EventValue.ID,
            BaseEvent = await Storage.GetEvent(e.EventValue.BaseEventID),
            ValueTypeEvent = await Storage.GetEvent(e.EventValue.ValueID),
            Value = e.EventValue.Value,
            ActorEvent = await Storage.GetEvent(e.EventValue.ActorEventID),
            Date = e.Date,
            Conditions = await GetDetailedCondition(e.Conditions)
        };
    }

    private async Task<string> GetDetailedCondition(ConditionRule rule) {
        if (rule is ConditionRule.EventConditionRule eventRule) {
            var e = await Storage.GetEvent(eventRule.EventID);
            return $"[{eventRule.EventID}] {e.EventValue.Value}";
        }
        else if (rule is ConditionRule.ComplexConditionRule complexRule && 1 == complexRule.Values.Count()) {
            return await GetDetailedCondition(complexRule.Values.Single());
        }
        else if (rule is ConditionRule.ConjunctionRule conjunctionRule) {
            var arms = String.Join(
                " AND ",
                await Task.WhenAll(
                    conjunctionRule.Values.Select(v => GetDetailedCondition(v))
                )
            );
            return $"({arms})";
        }
        else if (rule is ConditionRule.DisjunctionRule disjunctionRule) {
            var arms = String.Join(
                " OR ",
                await Task.WhenAll(
                    disjunctionRule.Values.Select(v => GetDetailedCondition(v))
                )
            );
            return $"({arms})";
        }
        else if (rule is ConditionRule.PropertyEqualityRule equalityRule) {
            var e = await Storage.GetAttribute(equalityRule.PropertyID);
            return $"{e.Label} = '{equalityRule.Value}'";
        }
        else if (rule is ConditionRule.PropertyInequalityRule inequalityRule) {
            var e = await Storage.GetAttribute(inequalityRule.PropertyID);
            return $"{e.Label} <> '{inequalityRule.Value}'";
        }
        else {
            throw new NotImplementedException();
        }
    }

    public async Task Refresh() {
        var result = await Task.WhenAll(Items.Select(GetDetailedEvent));
        detailedEvents = result;
    }
}