@inject IStorageAPI Storage
@inject TransactionsService Tx
@inject RoutingService Routing
@inject DialogService Dialog

<div class="card">
    <div class="card-body">
        <h5 class="card-title">
            <NavLink href="@Routing.IndividualsView(@Value.ID)">
                <strong>
                    <span>(@Value.ID) @Value.Label</span>
                </strong>
            </NavLink>

            @if (Value.Valid) {
                <span class="badge badge-success float-right">Valid</span>
            }
            else {
                <span class="badge badge-danger float-right">Invalid</span>
            }
        </h5>
        <div class="row">
            <div class="col-sm">
                <i class="icon feather-code text-muted"></i>
                <span>Model</span>
            </div>
            <div class="col-sm text-right">
                <NavLink href="@Routing.ModelsView(Value.Model.ID)">@Value.Model.Label</NavLink>
            </div>
        </div>
        <div class="row">
            <div class="col-sm">
                <i class="icon feather-user text-muted"></i>
                <span>Creator</span>
            </div>
            <div class="col-sm text-right">
                @if (Value.Actor.HasValue) {
                    <NavLink href="@Routing.IndividualsView(Value.Actor.Value)">@Value.ActorLabel</NavLink>
                }
                else {
                    @(Value.ActorLabel ?? "System")
                }
            </div>
        </div
        <hr/>
        @foreach (var attr in Value.Model.Attributes) {
            <div class="row">
                <div class="col-sm">
                    <strong>@attr.Label</strong>
                </div>
                <div class="col-sm text-right">
                    @if (IsEditable(attr)) {
                        var values = RenderValues(attr);
                        <button class="btn btn-link p-0 border-bottom" @onclick="@(() => HandleAssignAttribute(attr))">
                            @if (null == values) {
                                <i class="icon feather-alert-triangle text-warning"></i>
                                <span class="text-muted">Unassigned</span>
                            }
                            else {
                                @values
                            }
                        </button>

                    }
                    else {
                        <span>
                            @RenderValues(attr)
                        </span>
                    }
                </div>
            </div>
        }
        @foreach (var relation in Value.Model.Relations) {
            <div class="row">
                <div class="col-sm">
                    <strong>@relation.Label</strong>
                </div>
                <div class="col-sm text-right">
                    @if (IsEditable(relation)) {
                        var values = RenderValues(relation);
                        <button class="btn btn-link p-0 border-bottom" @onclick="@(() => HandleAssignRelation(relation))">
                            @if (null == values) {
                                <i class="icon feather-alert-triangle text-warning"></i>
                                <span class="text-muted">Unassigned</span>
                            }
                            else {
                                @values
                            }
                        </button>
                    }
                    else {
                        <span>
                            @RenderValues(relation)
                        </span>
                    }
                </div>
            </div>
        }
    </div>
</div>

@code {
    [Parameter]
    public IndividualData Value { get; set; }

    [Parameter]
    public EventCallback OnUpdate { get; set; }

    private bool IsEditable(IndividualAttrData attr) {
        if (attr.Cardinality == 0) {
            return true;
        }

        if (null == attr.Values?.Count()) {
            return true;
        }

        return attr.Values.Count() < attr.Cardinality;
    }

    private bool IsEditable(IndividualRelationData relation) {
        if (relation.Cardinality == 0) {
            return true;
        }

        if (null == relation.Values?.Count()) {
            return true;
        }

        return relation.Values.Count() < relation.Cardinality;
    }

    private string RenderValues(IndividualAttrData attr) {
        if (Value.Attributes.ContainsKey(attr.ID)) {
            return String.Join(',', Value.Attributes[attr.ID].Values.Select(v => v.ShownValue));
        }
        else {
            return null;
        }
    }

    private string RenderValues(IndividualRelationData relation) {
        if (Value.Relations.ContainsKey(relation.ID)) {
            return String.Join(',', Value.Relations[relation.ID].Values.Select(v => v.ShownValue));
        }
        else {
            return null;
        }
    }

    private async Task HandleAssignAttribute(IndividualAttrData attr) {
        var modelAttrData = await ModelAttrData.Instantiate(attr.AttachedProperty);
        var resultValues = await Dialog.SetAttributeValue(modelAttrData, attr.Values ?? Array.Empty<IBoxedValue>());

        if (null == resultValues) {
            return;
        }

        foreach (var value in resultValues) {
            await Tx.AssignIndividualProperty(Value.ID, attr.ID, value.PlainValue);
        }

        await OnUpdate.InvokeAsync(null);
    }

    private async Task HandleAssignRelation(IndividualRelationData relation) {
        var modelRelationData = await ModelRelationData.Instantiate(relation.AttachedProperty);
        var resultValues = await Dialog.SetRelationValue(modelRelationData, relation.Values ?? Array.Empty<IBoxedValue>());

        if (null == resultValues) {
            return;
        }

        foreach (var value in resultValues) {
            await Tx.AssignIndividualProperty(Value.ID, relation.ID, value.PlainValue);
        }

        await OnUpdate.InvokeAsync(null);
    }
}